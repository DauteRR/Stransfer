{"version":3,"sources":["utils/mediaUtils.tsx","components/Camera.tsx","components/DownloadableImage.tsx","components/DownloadableImageList.tsx","utils/indexedDatabase.tsx","utils/dimensions.tsx","components/App.tsx","serviceWorker.ts","index.tsx"],"names":["canvasBuffer","document","createElement","Camera","videoRef","React","createRef","state","isRecording","errorMessage","loadStream","stream","_this","media","srcObject","_","src","URL","createObjectURL","MediaUtils","getVideoElement","setState","takePhoto","_ref","width","height","context","getContext","drawImage","toDataURL","videoWidth","videoHeight","_this2","this","navigator","mediaDevices","getUserMedia","video","audio","then","cameraStream","catch","current","Error","react_default","a","className","props","ref","autoPlay","role","aria-label","Component","DownloadableImage","canvasRef","imageRef","isImageLoaded","onImageLoad","getCanvasElement","getImageElement","image","canvas","download","imageName","href","dataUrl","title","concat","onClick","deleteImage","date","getDownloadButton","hidden","alt","onLoad","DownloadableImageList","createPhotoListItem","imageData","index","key","src_components_DownloadableImage","String","map","IMAGE_DATA_OBJECT_STORE_NAME","idbPromise","idb","open","upgradeIdb","createObjectStore","keyPath","MAX_DIMENSIONS","App","cameraRef","getCameraComponent","camera","onNewPhoto","data","dimensions","aspectRatio","result","Object","objectSpread","getMaxDimensionsRespectingAspectRatio","newImageData","Date","now","db","transaction","objectStore","put","prevState","toConsumableArray","splice","findIndex","element","delete","IdbUtils","getAll","imageDataList","components_Camera","components_DownloadableImageList","Boolean","window","location","hostname","match","ReactDOM","render","src_components_App","getElementById","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.ee1cecab.chunk.js","sourcesContent":["// Buffer to store the images so we can\n// get their data URL\nconst canvasBuffer = document.createElement(\"canvas\");\n\n/**\n * Return a data url representing the given media with the given parameters\n *\n * @param {HTMLVideoElement} media The video to get the data URL from\n * @param {Object} parameters {width, height} Dimensions of the image\n * @returns {String} The data URL representing the given media\n */\nexport function mediaToDataUrl(\n  media: HTMLVideoElement, \n  { width, height }: {width: number, height: number}\n) {\n  canvasBuffer.width = width;\n  canvasBuffer.height = height;\n  const context = canvasBuffer.getContext(\"2d\");\n  if (!context)\n    return;\n  context.drawImage(media, 0, 0, width, height);\n  return canvasBuffer.toDataURL();\n}\n\n/**\n * Assigns a media source to a media element (video or audio)\n *\n * @param {MediaStream} stream Stream to load into the given media element\n * @param {HTMLMediaElement} media Media where the given stream will be loaded (video or audio)\n */\nexport function loadStreamToMedia(\n  stream: MediaStream, \n  media: HTMLMediaElement\n) {\n  // Try to use srcObject. If it doesn't work\n  // fallback to use URL.createObjectURL()\n  try {\n    media.srcObject = stream;\n  } catch (_) {\n    media.src = URL.createObjectURL(stream);\n  }\n}\n\n/**\n * Returns the relationship of the width to the height for the given video\n *\n * @param {HTMLVideoElement} video Video to get the width and height from\n */\nexport function getAspectRatio(\n  video: HTMLVideoElement\n) {\n  if (video.videoWidth > 0 && video.videoHeight > 0) {\n    return video.videoWidth / video.videoHeight;\n  } else {\n    throw new Error(\n      `Invalid dimensions {videoWidth: ${video.videoWidth}, videoHeight: ${\n        video.videoHeight\n      }}. They must be numbers greater than 0`\n    );\n  }\n}","import React, { Component } from \"react\";\nimport * as MediaUtils from \"../utils/mediaUtils\";\n\ninterface CameraProps {\n  className: string;\n}\n\ninterface CameraState {\n  isRecording: boolean;\n  errorMessage: string;\n}\n\nclass Camera extends Component<CameraProps, CameraState> {\n  videoRef = React.createRef<HTMLVideoElement>();\n\n  state = {\n    isRecording: false,\n    errorMessage: \"\"\n  };\n\n  componentDidMount() {\n    navigator.mediaDevices\n      .getUserMedia({ video: true, audio: false })\n      .then(cameraStream => this.loadStream(cameraStream))\n      .catch(_ => {\n        this.setState({\n          isRecording: false,\n          errorMessage: \"Access to camera not granted\"\n        });\n      });\n  }\n\n  getVideoElement(): HTMLVideoElement {\n    const video = this.videoRef.current;\n\n    if (!video) throw new Error(\"Video reference error\");\n\n    return video;\n  }\n\n  loadStream = (stream: MediaStream) => {\n    if (!this.state.isRecording) {\n      MediaUtils.loadStreamToMedia(stream, this.getVideoElement());\n\n      this.setState({\n        isRecording: true,\n        errorMessage: \"\"\n      });\n    }\n  };\n\n  takePhoto = () => {\n    if (!this.state.isRecording) {\n      return null;\n    }\n\n    return MediaUtils.mediaToDataUrl(this.getVideoElement(), {\n      width: this.getVideoElement().videoWidth, //this.props.photoWidth,\n      height: this.getVideoElement().videoHeight //this.props.photoHeight\n    });\n  };\n\n  render() {\n    if (this.state.errorMessage) {\n      return (\n        <div className={this.props.className}>\n          <p>{this.state.errorMessage}</p>\n        </div>\n      );\n    }\n\n    return (\n      <div className={this.props.className}>\n        <video\n          ref={this.videoRef}\n          autoPlay\n          role=\"application\"\n          aria-label=\"Camera\"\n        >\n          Cannot show the camera. Maybe it is because this browser doesn't\n          support the HTML5 \"video\" element\n        </video>\n      </div>\n    );\n  }\n}\n\nexport default Camera;\n","import React, { Component } from \"react\";\nimport \"./DownloadableImage.scss\";\n\ninterface DownloadableImageProps {\n  width: number;\n  height: number;\n  dataUrl: string;\n  alt: string;\n  imageName: string;\n  date: number;\n  deleteImage: Function;\n}\n\ninterface DownloadableImageState {\n  isImageLoaded: boolean;\n}\n\nclass DownloadableImage extends Component<\n  DownloadableImageProps,\n  DownloadableImageState\n> {\n  canvasRef = React.createRef<HTMLCanvasElement>();\n  imageRef = React.createRef<HTMLImageElement>();\n\n  state = {\n    isImageLoaded: false\n  };\n\n  getImageElement() {\n    const image = this.imageRef.current;\n\n    if (!image) throw new Error(\"Image reference error\");\n\n    return image;\n  }\n\n  getCanvasElement() {\n    const canvas = this.canvasRef.current;\n\n    if (!canvas) throw new Error(\"Canvas reference error\");\n\n    return canvas;\n  }\n\n  getDownloadButton() {\n    if (this.state.isImageLoaded) {\n      return (\n        <a download={this.props.imageName} href={this.props.dataUrl}>\n          <span\n            className=\"options__download-icon\"\n            title=\"Download\"\n            aria-label=\"Download\"\n          >\n            D\n          </span>\n        </a>\n      );\n    } else {\n      return <p>{`\"${this.props.imageName}\"`} not available yet</p>;\n    }\n  }\n\n  onImageLoad = () => {\n    const context = this.getCanvasElement().getContext(\"2d\");\n    if (context) {\n      context.drawImage(\n        this.getImageElement(),\n        0,\n        0,\n        this.props.width,\n        this.props.height\n      );\n      this.setState({ isImageLoaded: true });\n    }\n  };\n\n  render() {\n    return (\n      <div className=\"DownloadableImage\">\n        <div className=\"DownloadableImage__options\">\n          <button\n            onClick={() => this.props.deleteImage(this.props.date)}\n            className=\"options__delete-button\"\n            title=\"Delete\"\n            aria-label=\"Delete\"\n          >\n            &times;\n          </button>\n          {this.getDownloadButton()}\n        </div>\n        <canvas\n          width={this.props.width}\n          height={this.props.height}\n          ref={this.canvasRef}\n          hidden\n        />\n        <img\n          className=\"DownloadableImage__image\"\n          src={this.props.dataUrl}\n          alt={this.props.alt}\n          width={this.props.width}\n          height={this.props.height}\n          onLoad={this.onImageLoad}\n          ref={this.imageRef}\n        />\n      </div>\n    );\n  }\n}\n\nexport default DownloadableImage;\n","import React, {Component} from 'react';\nimport DownloadableImage from './DownloadableImage';\n\ninterface DownloadableImageListProps {\n  imageData: {\n    dataUrl: string, \n    width: number, \n    height: number,\n    date: number\n  }[];\n  deleteImage: Function;\n}\n\nclass DownloadableImageList extends Component<\n  DownloadableImageListProps\n> {\n\n  createPhotoListItem = (\n    imageData: {\n      dataUrl: string, \n      width: number, \n      height: number,\n      date: number\n    },\n    index: number\n  ) => {\n    return (\n      <li key={index} className=\"result-container\">\n        <DownloadableImage\n          dataUrl={imageData.dataUrl}\n          width={imageData.width}\n          height={imageData.height}\n          alt={String(index)}\n          imageName={String(index)}\n          date={imageData.date}\n          deleteImage={this.props.deleteImage}\n        />\n      </li>\n    );\n  }\n\n  render() {\n    return (\n      <ul className=\"container result-list\">\n        {this.props.imageData.map(this.createPhotoListItem)}\n      </ul>\n    );\n  }\n}\n\nexport default DownloadableImageList;","import idb from \"idb\";\n\nconst APP_IDB_NAME = \"StyleTransfer\";\nconst APP_IDB_VERSION = 1;\nconst IMAGE_DATA_OBJECT_STORE_NAME = \"image_data\";\n\nconst idbPromise = idb.open(APP_IDB_NAME, APP_IDB_VERSION, upgradeIdb => {\n  upgradeIdb.createObjectStore(IMAGE_DATA_OBJECT_STORE_NAME, {\n    keyPath: \"date\"\n  });\n});\n\nexport function saveImageData(data: object) {\n  return idbPromise.then(db =>\n    db.transaction(IMAGE_DATA_OBJECT_STORE_NAME, \"readwrite\")\n      .objectStore(IMAGE_DATA_OBJECT_STORE_NAME)\n      .put(data)\n  );\n}\n\nexport function deleteImageData(key: number) {\n  return idbPromise.then(db =>\n    db.transaction(IMAGE_DATA_OBJECT_STORE_NAME, \"readwrite\")\n      .objectStore(IMAGE_DATA_OBJECT_STORE_NAME)\n      .delete(key)\n  );\n}\n\nexport function getAllImageData() {\n  return idbPromise.then(db =>\n    db.transaction(IMAGE_DATA_OBJECT_STORE_NAME, \"readonly\")\n      .objectStore(IMAGE_DATA_OBJECT_STORE_NAME)\n      .getAll()\n  );\n}\n","/** \n * Video and images maximum dimensions. If we were to allow\n * arbitrary large video or images the app would be much slower.\n * \n * Also these needs to be square because ML5js styleTransfer needs\n * square images\n */\nexport const MAX_DIMENSIONS = { width: 300, height: 300 };\n\n/**\n * Returns whether the given dimensions are in the right bounds or not\n * \n * @param {Object} dimensions {width, height} Dimensions to check\n * @returns Whether the given dimensions are in the right bounds or not\n */\nexport function areCorrectDimensions(\n  dimensions: {width:number, height:number}\n) {\n  return (\n    dimensions.width > 0 &&\n    dimensions.width <= MAX_DIMENSIONS.width &&\n    dimensions.height > 0 &&\n    dimensions.height <= MAX_DIMENSIONS.height\n  );\n}\n\n/**\n * Returns the maximum dimensions respecting the given aspect ratio\n *\n * @param {Number} aspectRatio Width to height relationship that dimensions need to respect\n * @returns {Object} Dimensions respecting the aspect ratio\n */\nexport function getMaxDimensionsRespectingAspectRatio(aspectRatio: number) {\n  const result = { ...MAX_DIMENSIONS };\n\n  // The dimensions will be the maximum allowed but respecting\n  // the aspect ratio given (else the media will look squeezed)\n  if (aspectRatio < 1) {\n    // The width needs to be <= than the height\n    result.width *= aspectRatio;\n  } else {\n    // The height needs to be <= than the width\n    result.height /= aspectRatio;\n  }\n\n  return result;\n}","import React, { Component } from \"react\";\nimport Camera from \"./Camera\";\nimport DownloadableImageList from \"./DownloadableImageList\";\nimport * as MediaUtils from \"../utils/mediaUtils\";\nimport * as IdbUtils from \"../utils/indexedDatabase\";\nimport { getMaxDimensionsRespectingAspectRatio } from \"../utils/dimensions\";\nimport \"../index.css\";\nimport \"./App.scss\";\n\ninterface AppState {\n  imageData: object[];\n}\n\nclass App extends Component<{}, AppState> {\n  cameraRef = React.createRef<Camera>();\n\n  state = {\n    imageData: []\n  };\n\n  componentDidMount() {\n    IdbUtils.getAllImageData().then(imageDataList =>\n      this.setState({ imageData: imageDataList })\n    );\n  }\n\n  getCameraComponent = () => {\n    const camera = this.cameraRef.current;\n\n    if (!camera) throw new Error(\"Camera reference error\");\n\n    return camera;\n  };\n\n  onNewPhoto = () => {\n    const camera = this.getCameraComponent();\n    const cameraAspectRatio = MediaUtils.getAspectRatio(\n      camera.getVideoElement()\n    );\n    const dimensions = getMaxDimensionsRespectingAspectRatio(cameraAspectRatio);\n    const newImageData = {\n      date: Date.now(),\n      dataUrl: camera.takePhoto(),\n      width: dimensions.width,\n      height: dimensions.height\n    };\n\n    IdbUtils.saveImageData(newImageData);\n    this.setState(prevState => ({\n      imageData: [...prevState.imageData, newImageData]\n    }));\n  };\n\n  deleteImage = (key: number) => {\n    this.setState(prevState => {\n      prevState.imageData.splice(\n        prevState.imageData.findIndex((element: { date?: number }) => {\n          return element.date === key;\n        }),\n        1\n      );\n      return {\n        imageData: prevState.imageData\n      };\n    });\n\n    IdbUtils.deleteImageData(key);\n  };\n\n  render() {\n    return (\n      <div className=\"centered\">\n        <div className=\"App__camera-container\">\n          <Camera ref={this.cameraRef} className=\"camera-container__camera\" />\n          <button\n            onClick={this.onNewPhoto}\n            className=\"camera-container__button button\"\n            aria-label=\"Take photo\"\n            title=\"Take photo\"\n          />\n        </div>\n        <DownloadableImageList\n          imageData={this.state.imageData}\n          deleteImage={this.deleteImage}\n        />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}